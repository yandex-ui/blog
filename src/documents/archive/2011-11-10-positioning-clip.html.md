---
title: Свойство clip (нюансы позиционирования, часть вторая)
author: Роман Комаров
tags: [CSS, вёрстка, позиционирование]
---

В продолжение [серии статей про позиционирование][]: рассказ о свойстве `clip`.

Это свойство вряд ли встретишь в современной вёрстке: кроме того, что для его работы необходимо абсолютное позиционирование, синтаксис свойства заметно отличается от всего, что есть в CSS.

Взгляните на этот пример:

    clip: rect(-20px, 400px, auto, 0);

Изначально задумывалось, что у этого свойства в будущем будет множество различных вариантов обрезания контента, но в итоге, как в самом начале описали только `rect()`, так он и остался. Единственное значение (помимо `inherit`), которое может быть у `clip`, — `auto`, являющееся значением по умолчанию, и которое нужно применять, если возникает необходимость отменить действие уже применённого `clip`.

Важно: в IE до 7-й версии включительно был реализован только один вариант синтаксиса — без запятых, через пробелы. По [спецификации][] браузеры должны понимать оба синтаксиса, так что можно было бы всегда писать через пробелы. Однако в IE8 опять всё не так — он понимает только вариант с запятыми. Поэтому в идеале надо писать оба варианта:

![Иллюстрация работы синтаксиса clip (взято из спецификации)][]

    clip: rect(-20px 400px auto 0); /* lte IE7 */
    clip: rect(-20px, 400px, auto, 0);


Итак, при помощи `clip: rect()`, как следует из названия (rectangle — прямоугольник), можно задавать границы обрезания абсолютно позиционируемого блока. На первый взгляд, четыре цифровых значения задаются привычно: они идут в стандартном порядке `top`-`right`-`bottom`-`left`. Но если для абсолютного позиционирования отсчёт идёт от краёв блока, то для свойства `clip` отсчёт всегда идёт сверху-вниз и слева-направо. Кроме того, эти свойства могут принимать только абсолютные численные значения (без процентов, но можно отрицательные) или ключевое слово `auto`.

Ключевое слово `auto` означает, что та или иная координата обрезания будет совпадать с соответствующей границей элемента. При этом для верхней и левой границ эквивалентом будет `0`, тогда как для правой и нижней границ эквивалента нет.

Итак, что мы имеем:

1. Не имеет смысла задавать нижнюю границу меньше верхней, а правую меньше левой — так как область действия свойства `clip` рассчитывается сверху-вниз и слева-направо, то «перекрытия» схлопнутся до ноля.

2. Невозможно задать обрезание пропорциональное ширине блока: единственный вариант, при котором как-то учитываются размеры блока, — указание для границ значения `auto`, в ином случае мы не можем ни на что опираться.

3. Для свойства `clip` работают CSS3-транзишны. Но, как и для остальных свойств, они работают только при переходе между фиксированными единицами: переход от пикселей к `auto` не будет анимирован.

4. При помощи отрицательных значений можно отображать часть элемента, которая находится за пределами его границ (например тень), или иные блоки, которые находятся или выступают за пределы блока с `clip`. Нормально управлять этим можно только сверху и слева: справа и снизу нельзя задать отрицательные границы из-за того, что они считаются по «неправильному» алгоритму. Чтобы обойти это можно использовать «хак» — показать всю нижнюю или правую часть задав заранее очень большие границы: `rect(0, 99999px, 99999px, 0)`.

    Тут может появиться небольшая проблема: в Опере такое поведение не работает для тени, если для блока с `clip` задан ещё и `overflow` отличный от `visible`.

    Вот пример использования отрицательных или очень больших значений для отображения только нужных частей тени у элемента:

    [![Пример использования отрицательных и очень больших значений для отображения только нужных частей тени у элемента][]][1]

5. Если скрытая часть блока через `clip` оказывается за пределами родителя с `overflow: auto`, то во всех браузерах (кроме тех, что на движке webkit, и старых IE) эта скрытая часть не будет влиять на скролл.

6. Свойство `clip` можно использовать как удобный способ скрытия контента так, чтобы он оставался доступным для копирования в буфер обмена или иных, не визуальных, методов представления информации. Подробнее этот момент описан в [этой статье][] (на английском языке). Не вдаваясь в подробности реализации, приведу только код:

        .invisible {
            position: absolute !important;
            clip: rect(1px 1px 1px 1px); /* IE6, IE7 */
            clip: rect(1px, 1px, 1px, 1px);
            }
    
    При помощи такого кода мы, по-первых, вынимаем блок из потока, во-вторых, скрываем его визуально. Все иные методы или громоздки, или могут сделать контент недоступным, тогда как метод с использованием `clip` прост, надёжен и влияет только на визуальную сторону.

    [Страница с примерами различных вариантов использования свойства клип][1]

## Продолжение следует

В этой статье мы рассмотрели только свойство `clip`, в последующих статьях в серии мы расскажем про фиксированное позиционирование, понятие стекового контекста и о многих других аспектах позиционирования.

[серии статей про позиционирование]: ../positioning/

[Пример использования отрицательных и очень больших значений для отображения только нужных частей тени у элемента]: http://img-fotki.yandex.ru/get/5820/1076905.1/0_6c7d6_f9df65b3_orig

[Иллюстрация работы синтаксиса clip (взято из спецификации)]: http://img-fotki.yandex.ru/get/5313/1076905.1/0_6c7d5_b87ab235_orig

[этой статье]: http://adaptivethemes.com/using-css-clip-as-an-accessible-method-of-hiding-content

[1]: http://yandex-ui.github.com/Examples/positioning/clip/

[спецификации]: http://www.w3.org/TR/CSS2/visufx.html#clipping
