<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7,IE=edge"><meta name="viewport" content="width=device-width"><meta name="generator" content="DocPad v6.65.0" /><link rel="stylesheet" href="/style.css"></head><body><div class="page"><h1 class="page-head">Архив клуба разработки интерфейсов</h1><div class="page-content"><header><h1>Свойство clip (нюансы позиционирования, часть вторая)</h1><p>Опубликовано Thu Jul 24 2014 15:10:25 GMT+0400 (MSK). Автор: Роман Комаров.</p></header><p>В продолжение <a href="../positioning/">серии статей про позиционирование</a>: рассказ о свойстве <code>clip</code>.</p>
<p>Это свойство вряд ли встретишь в современной вёрстке: кроме того, что для его работы необходимо абсолютное позиционирование, синтаксис свойства заметно отличается от всего, что есть в CSS.</p>
<p>Взгляните на этот пример:</p>
<pre><code>clip: rect(-20px, 400px, auto, 0);
</code></pre><p>Изначально задумывалось, что у этого свойства в будущем будет множество различных вариантов обрезания контента, но в итоге, как в самом начале описали только <code>rect()</code>, так он и остался. Единственное значение (помимо <code>inherit</code>), которое может быть у <code>clip</code>, — <code>auto</code>, являющееся значением по умолчанию, и которое нужно применять, если возникает необходимость отменить действие уже применённого <code>clip</code>.</p>
<p>Важно: в IE до 7-й версии включительно был реализован только один вариант синтаксиса — без запятых, через пробелы. По <a href="http://www.w3.org/TR/CSS2/visufx.html#clipping">спецификации</a> браузеры должны понимать оба синтаксиса, так что можно было бы всегда писать через пробелы. Однако в IE8 опять всё не так — он понимает только вариант с запятыми. Поэтому в идеале надо писать оба варианта:</p>
<p><img src="http://img-fotki.yandex.ru/get/5313/1076905.1/0_6c7d5_b87ab235_orig" alt="Иллюстрация работы синтаксиса clip (взято из спецификации)"></p>
<pre><code>clip: rect(-20px 400px auto 0); /* lte IE7 */
clip: rect(-20px, 400px, auto, 0);
</code></pre><p>Итак, при помощи <code>clip: rect()</code>, как следует из названия (rectangle — прямоугольник), можно задавать границы обрезания абсолютно позиционируемого блока. На первый взгляд, четыре цифровых значения задаются привычно: они идут в стандартном порядке <code>top</code>-<code>right</code>-<code>bottom</code>-<code>left</code>. Но если для абсолютного позиционирования отсчёт идёт от краёв блока, то для свойства <code>clip</code> отсчёт всегда идёт сверху-вниз и слева-направо. Кроме того, эти свойства могут принимать только абсолютные численные значения (без процентов, но можно отрицательные) или ключевое слово <code>auto</code>.</p>
<p>Ключевое слово <code>auto</code> означает, что та или иная координата обрезания будет совпадать с соответствующей границей элемента. При этом для верхней и левой границ эквивалентом будет <code>0</code>, тогда как для правой и нижней границ эквивалента нет.</p>
<p>Итак, что мы имеем:</p>
<ol>
<li><p>Не имеет смысла задавать нижнюю границу меньше верхней, а правую меньше левой — так как область действия свойства <code>clip</code> рассчитывается сверху-вниз и слева-направо, то «перекрытия» схлопнутся до ноля.</p>
</li>
<li><p>Невозможно задать обрезание пропорциональное ширине блока: единственный вариант, при котором как-то учитываются размеры блока, — указание для границ значения <code>auto</code>, в ином случае мы не можем ни на что опираться.</p>
</li>
<li><p>Для свойства <code>clip</code> работают CSS3-транзишны. Но, как и для остальных свойств, они работают только при переходе между фиксированными единицами: переход от пикселей к <code>auto</code> не будет анимирован.</p>
</li>
<li><p>При помощи отрицательных значений можно отображать часть элемента, которая находится за пределами его границ (например тень), или иные блоки, которые находятся или выступают за пределы блока с <code>clip</code>. Нормально управлять этим можно только сверху и слева: справа и снизу нельзя задать отрицательные границы из-за того, что они считаются по «неправильному» алгоритму. Чтобы обойти это можно использовать «хак» — показать всю нижнюю или правую часть задав заранее очень большие границы: <code>rect(0, 99999px, 99999px, 0)</code>.</p>
<p> Тут может появиться небольшая проблема: в Опере такое поведение не работает для тени, если для блока с <code>clip</code> задан ещё и <code>overflow</code> отличный от <code>visible</code>.</p>
<p> Вот пример использования отрицательных или очень больших значений для отображения только нужных частей тени у элемента:</p>
<p> <a href="http://yandex-ui.github.com/Examples/positioning/clip/"><img src="http://img-fotki.yandex.ru/get/5820/1076905.1/0_6c7d6_f9df65b3_orig" alt="Пример использования отрицательных и очень больших значений для отображения только нужных частей тени у элемента"></a></p>
</li>
<li><p>Если скрытая часть блока через <code>clip</code> оказывается за пределами родителя с <code>overflow: auto</code>, то во всех браузерах (кроме тех, что на движке webkit, и старых IE) эта скрытая часть не будет влиять на скролл.</p>
</li>
<li><p>Свойство <code>clip</code> можно использовать как удобный способ скрытия контента так, чтобы он оставался доступным для копирования в буфер обмена или иных, не визуальных, методов представления информации. Подробнее этот момент описан в <a href="http://adaptivethemes.com/using-css-clip-as-an-accessible-method-of-hiding-content">этой статье</a> (на английском языке). Не вдаваясь в подробности реализации, приведу только код:</p>
<pre><code> .invisible {
     position: absolute !important;
     clip: rect(1px 1px 1px 1px); /* IE6, IE7 */
     clip: rect(1px, 1px, 1px, 1px);
     }
</code></pre><p> При помощи такого кода мы, по-первых, вынимаем блок из потока, во-вторых, скрываем его визуально. Все иные методы или громоздки, или могут сделать контент недоступным, тогда как метод с использованием <code>clip</code> прост, надёжен и влияет только на визуальную сторону.</p>
<p> <a href="http://yandex-ui.github.com/Examples/positioning/clip/">Страница с примерами различных вариантов использования свойства клип</a></p>
</li>
</ol>
<h2 id="-">Продолжение следует</h2>
<p>В этой статье мы рассмотрели только свойство <code>clip</code>, в последующих статьях в серии мы расскажем про фиксированное позиционирование, понятие стекового контекста и о многих других аспектах позиционирования.</p>
</div></div><!-- Yandex.Metrika counter --><div style="display:none;"><script type="text/javascript">(function(w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter8530063 = new Ya.Metrika({id:8530063, enableAll: true}); } catch(e) { } }); })(window, "yandex_metrika_callbacks");</script></div><script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script><noscript><div><img src="//mc.yandex.ru/watch/8530063" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>