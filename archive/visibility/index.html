<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7,IE=edge"><meta name="viewport" content="width=device-width"><meta name="generator" content="DocPad v6.65.0" /><link  rel="stylesheet" href="/blog/style.css" /></head><body><div class="page"><h1 class="page-head"><a href="../">Архив клуба по разработке интерфейсов</a></h1><div class="page-content"><header><h1>CSS: visibility</h1><p>Опубликовано Thu Jul 24 2014 15:02:26 GMT+0400 (MSK). Автор: Роман Комаров.</p></header><p><img src="http://img-fotki.yandex.ru/get/5409/1076905.0/0_5ffce_c06f06a8_orig" alt="Иллюстрация различных значений visibility"></p>
<p>В <a href="http://www.w3.org/TR/css3-box/#visibility">спецификациях CSS</a> есть такое свойство — <code>visibility</code>. Оно поддерживается большинством браузеров. Это свойство понимает даже IE6, а значит его можно применять совершенно спокойно.</p>
<p>Свойство <code>visibility</code> очень простое, у него есть три возможных значения: <code>visible</code>, <code>hidden</code> и <code>collapse</code> (помимо вездесущего <code>inherit</code>, конечно). В этой статье мы больше внимания уделим двум значениям:</p>
<ol>
<li><p><code>visibility: hidden</code> — блок становится невидим и перестаёт взаимодействовать с пользователем — не реагирует на клик, ховер, перестаёт быть видимым для скрин-ридеров и т.д. Но блок продолжает влиять на раскладку документа, то есть занимает положенное ему место и является значимым для reflow.</p>
</li>
<li><p><code>visibility: visible</code> — блок отображается даже в том случае, если какой-то из родителей скрыт через <code>visibility: hidden</code>. Это важный момент, основываясь на котором можно сделать много разных вещей.</p>
</li>
</ol>
<h2 id="-sup-sup-2-">Применение для резервирования места<a href="http://yandex-ui.github.com/Examples/visibility/"><sup>пример</sup></a></h2>
<p><img src="http://img-fotki.yandex.ru/get/5409/1076905.0/0_5ffcf_5f386d85_orig" alt="Иллюстрация применения для резервирования места при вёрстке вкладок"></p>
<p>Тот факт, что скрытый через <code>visibility</code> блок продолжает влиять на раскладку, можно использовать несколькими способами. Например, при вёрстке блоков с вкладками можно сделать так, что скрытые блоки будут занимать положенное им по вертикали место. И при переключении между вкладками содержимое не будет «прыгать».</p>
<p>Например, можно поменять в <a href="http://chikuyonok.ru/2009/04/dl-tabs/">методе Сергея Чикуёнка</a> скрытие с <code>display</code> на <code>visibility</code>. В этом случае раскладка останется той же, потому что основана на флоатах и отрицательных полях. Так что замена <code>display</code> на что-то другое ничего не сломает.</p>
<h2 id="-">Применение при проблемах с флэшем</h2>
<p>В сложных интерфейсах часто возникают ситуации, когда необходимо скрывать какие-то блоки, внутри которых находится флэш или айфреймы. Обычно это ничем не грозит, но в некоторых случаях могут возникнуть проблемы — подвисания, закрытие браузера и т.п.</p>
<p>Чаще всего скрытие блоков делают через <code>display: none</code> (мы обычно применяем его не напрямую в атрибуте <code>style</code>, а через класс <code>g-hidden</code>). Чтобы избежать возникновения ошибок из-за скрытия блока, мы создали новый класс. Выглядел он примерно так:</p>
<pre><code>.g-invisible
{
    position: absolute;
    top: -9999px;
    left: -9999px;
    visibility: hidden;
}
</code></pre><p>Этими стилями мы, во-первых, вырывали блок из потока, во-вторых, скрывали его визуально. Проблема с флэшем решилась.</p>
<h2 id="-css3-">Использование для CSS3-переходов</h2>
<p>Часто для скрытия или отображения каких-нибудь блоков используют изменение свойства <code>opacity</code>. Вместе с ним можно применять и <code>visibility</code>. В большинстве браузеров, поддерживающих CSS3-переходы, переключение этих свойств будет происходить правильно (блок будет виден и будет взаимодействовать с интерфейсом, когда <code>opacity</code> больше ноля). Однако в браузере Opera такое поведение пока работает неверно: переключение <code>visibility</code> происходит всегда в конце анимации, так что при «появлении» блока анимацию не будет видно.</p>
<h2 id="-">Невидимый слой для создания контекста позиционирования</h2>
<p><img src="http://img-fotki.yandex.ru/get/4707/1076905.0/0_5ffd0_2b97cf_orig" alt="Иллюстрация абсолютно спозиционированного слоя. Можно использовать для попапов, тултипов и прочих подобных вещей."></p>
<p>При послойной вёрстке на отрицательных полях или с применением абсолютного позиционирования может возникнуть ситуация, когда для правильной расстановки блоков или колонок необходимо иметь общего родителя. Иногда не получается (или получается, но дорого) сделать так, чтобы этот родитель не перекрывал уже имеющиеся на странице блоки. В таком случае можно легко решить задачу, задав этому родителю <code>visibility: hidden</code>, а детям — <code>visibility: visible</code>. Родитель не будет кликабелен, но на него можно будет опираться при расчете позиционирования и размеров детей.</p>
<h2 id="-sup-sup-5-">Вёрстки, зависимая от ширины скроллбаров<a href="http://yandex-ui.github.com/Examples/visibility/scroll/"><sup>пример</sup></a></h2>
<p>Иногда использование <code>visibility</code> помогает решить задачи, которые иначе можно решить только яваскриптом.</p>
<p>Допустим, есть блок со скроллбаром (<code>overflow: scroll</code>). Нам нужно расположить элемент вне этого блока так, чтобы ширина элемента была равна ширине контента блока за вычетом ширины скроллбара. Например, это может быть тулбар или декоративный элемент. Проблема в том, что в разных браузерах и операционных системах ширина скроллбаров в вёрстке разная (и узнать точное значение можно только используя яваскрипт), так что мы не можем на неё опираться.</p>
<p>Задача решается так:</p>
<p>Блоку, для которого нам нужна ширина без скроллбара, задаём следующие свойства:</p>
<pre><code>overflow: scroll;
visibility: hidden;
height: 99px;
</code></pre><p>Блоку внутри задаём всё что нужно + <code>visibility: visible</code>. Ширина ребёнка будет равна доступной ширине родителя, но так как у родителя есть скроллбар, то мы получим ширину родителя за вычетом скроллбара.</p>
<p>Тут есть важный момент — в некоторых браузерах, если у блока маленькая высота, то даже при <code>overflow: scroll</code> скроллбары не будут отрисованы и место под них не будет зарезервировано. Именно поэтому необходимо задать блоку высоту, при которой скроллбары точно появятся. Так как этот блок будет скрыт, то достаточно будет учитывать его размеры при позиционировании.</p>
<h2 id="-inherit-">Значение <code>inherit</code></h2>
<p>Если необходимо показать блок, скрытый через <code>visibility</code>, перекрывая его новым селектором, то надо использовать <code>visibility: inherit</code>, а не <code>visibility: visible</code>. Если возникнет ситуация с вложенными <code>visibility: hidden</code>, то блок, который логически должен быть скрыт, будет показан. Забавный факт: в IE6 значение <code>inherit</code> работает для свойства <code>visibility</code>, так что применять его можно без опаски.</p>
<h2 id="-">Известные проблемы</h2>
<ul>
<li><p>В браузерах на движке webkit существует проблема — если у скрытого блока со скроллбаром прописан <code>z-index</code>, то область, которая попадает под место со скроллбаром, перестаёт прокликиваться. Решение — перенести <code>z-index</code> на внутренний элемент.</p>
</li>
<li><p>Опять webkit — если у скрытого элемента задан <code>position</code>, который отличен от <code>static</code>, а у внутреннего элемента <code>overfow</code> — от <code>visible</code>, то элемент не будет показан при <code>visibility: visible</code>, пока ему не задашь позиционирование.</p>
</li>
<li><p>В IE9 не работает <code>visibility: visible</code> для псевдоэлементов скрытого блока.</p>
</li>
</ul>
<h2 id="-">Примеры</h2>
<ul>
<li><a href="http://yandex-ui.github.com/Examples/visibility/">Вёрстка вкладок с применением <code>visibility</code></a></li>
<li><a href="http://yandex-ui.github.com/Examples/visibility/scroll/">Вёрстка с учётом ширины скроллбаров</a></li>
</ul>
</div></div><!-- Yandex.Metrika counter --><div style="display:none;"><script type="text/javascript">(function(w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter8530063 = new Ya.Metrika({id:8530063, enableAll: true}); } catch(e) { } }); })(window, "yandex_metrika_callbacks");</script></div><script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script><noscript><div><img src="//mc.yandex.ru/watch/8530063" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>