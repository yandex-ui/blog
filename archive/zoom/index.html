<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7,IE=edge"><meta name="viewport" content="width=device-width"><meta name="generator" content="DocPad v6.65.0" /><link  rel="stylesheet" href="/blog/style.css" /></head><body><div class="page"><h1 class="page-head">Архив клуба разработки интерфейсов</h1><div class="page-content"><header><h1>Артефакты масштабирования</h1><p>Опубликовано Thu Jul 24 2014 15:01:19 GMT+0400 (MSK). Автор: Роман Комаров.</p></header><p>Несколько лет назад считалось хорошим тоном учитывать в вёрстке ±2 шага масштабирования текста, то есть многие вещи надо было верстать, используя относительные единицы <code>em</code>. Но сейчас в игру вступило полностраничное масштабирование документов, практически вытеснив масштабирование текста.</p>
<p>Почти все современные браузеры по умолчанию масштабируют весь документ (опция по изменению только размера шрифта осталась, но используется всё реже). Кроме того, мобильные устройства распространяются всё шире, а на них полностраничное масштабирование используется постоянно — это один из основных способов взаимодействия со страницами.</p>
<p>Однако при реализации полностраничного масштабирования существует довольно много проблем. Большинство из них связано с появлением различных графических артефактов, возникающих из-за особенностей округления при рендеринге отмасштабированных блоков. В этой статье мы рассмотрим несколько подобных артефактов и расскажем, как их устранить.</p>
<h2 id="-sup-sup-3-">Проблемы с кадрированием спрайтов<a href="http://yandex-ui.github.com/Examples/zooming/"><sup>пример</sup></a></h2>
<p>Спрайты основательно вошли в арсенал современного верстальщика, оказавшись удобным способом предзагрузки изображений и избавления от лишних запросов. Но не все учитывают, что практически в любом браузере при масштабировании страницы есть проблемы с отображением перехода от одного кадра спрайта к другому.</p>
<p>Основная проблема — при увеличении масштаба по краям блоков начинают просвечивать части других кадров.</p>
<p><img src="http://img-fotki.yandex.ru/get/4518/1076905.1/0_65357_198b451a_orig" alt="Сравнительная таблица масштабирования в разных браузерах"></p>
<p>Эта проблема возникает во всех современных десктопных браузерах при увеличении страницы зумом, исключение — Firefox. Исправляется она довольно очевидным способом (хотя его применение для уже готовых больших спрайтов может и отнять какое-то время). Достаточно добавить между кадрами спрайта однопиксельные отступы, прозрачные для <code>png</code> или <code>gif</code> и цвета предполагаемого фона для <code>jpg</code>. И при изменении масштаба теперь будут просвечивать именно эти прозрачные пиксели.</p>
<p><img src="http://img-fotki.yandex.ru/get/4813/1076905.1/0_65358_8452d5d3_orig" alt="Исправленные кадры спрайта при масштабировании"></p>
<p>В iOS те же проблемы возникают даже при уменьшении масштаба, при этом исправление через отступы может чуть больше замыливать результат. Но в iOS есть и второй способ исправления — нужно применить к блоку с кадром спрайта магический хак <code>-webkit-transform: translateZ(0)</code>, который включает аппаратное ускорение рендеринга. А в сочетании с исправлением промежутком кадры масштабируются практически идеально.</p>
<p><img src="http://img-fotki.yandex.ru/get/5014/1076905.1/0_65369_4a99af45_orig" alt="Варианты исправлений для iPhone 4"></p>
<h2 id="-sup-sup-4-">Проблемы при позиционировании блоков<a href="http://yandex-ui.github.com/Examples/zooming/blocks/"><sup>пример</sup></a></h2>
<p>Аналогичные проблемы могут возникать и в вёрстке без картинок. Например, если нам надо расставить блоки так, чтобы из нескольких прямоугольников получалась цельная фигура. </p>
<p>Такие проблемы могут проявляться редко, обычно в каких-то сложных условиях. Например, в Firefox, при абсолютном позиционировании блока с использованием свойства <code>clip</code>, или в браузерах на движке webkit при вёрстке с использованием плавающих блоков. </p>
<p>Во всех случаях лучший метод исправления — перевёрстка. В случае с плавающими блоками надо экспериментировать с комбинациями относительного позиционирования и сдвигов через <code>margin</code>.</p>
<p>Например, если у нас есть такие блоки:</p>
<pre><code>.b-block {
    padding: 1em;
    }
    .b-block__inner {
        float: right;

        width:4em;
        height:3em;
        margin: -1em -5em 0 0;
        }
</code></pre><p>Исправление для внутреннего блока будет таким:</p>
<pre><code>.b-block__inner {
    position: relative;
    left: 4em;

    float: right;

    width:4em;
    height:3em;

    margin: -1em -1em 0 -4em;
    }
</code></pre><p>Здесь мы сначала компенсируем <code>padding</code> у родителя при помощи <code>margin</code>, а потом дополнительно смещаем блок позиционированием.</p>
<p>Кстати, для iOS эти проблемы также можно исправить через включение аппаратного ускорения рендеринга, при этом исправление через перевёрстку не всегда будут срабатывать. Итого, лучше всего использовать оба варианта — так мы добьёмся работоспособности блока везде.</p>
<p>Пример бага в webkit при вёрстке с использованием плавающих блоков можно увидеть на <a href="http://yandex-ui.github.com/Examples/zooming/blocks/">этой странице</a> (не забудьте менять масштаб).</p>
</div></div><!-- Yandex.Metrika counter --><div style="display:none;"><script type="text/javascript">(function(w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter8530063 = new Ya.Metrika({id:8530063, enableAll: true}); } catch(e) { } }); })(window, "yandex_metrika_callbacks");</script></div><script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script><noscript><div><img src="//mc.yandex.ru/watch/8530063" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>